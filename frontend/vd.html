<!doctype html>
<html>
<head>
  <title>VisiData Cloud</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="assets/vendor/xterm.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono&display=swap">
  <style>
    body {
      display: flex;
      flex-direction: column;

      margin: 0;
      height: 100vh;
    }

    #terminal {
      flex: auto;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>
  <script src="assets/vendor/xterm.js"></script>
  <script src="assets/vendor/xterm-addon-attach.js"></script>
  <script src="assets/vendor/xterm-addon-fit.js"></script>
  <script>
    async function POST(url, options = {}) {
      const response = await fetch(url, {...options, method: "POST"});

      if (!response.ok) {
        log("request.failed", {response});
        throw `POST ${url} failed`;
      }

      return response;
    }

    function log(msg, data = {}) {
      const level = msg.match(/(^|\b)failed(\b|$)/)
        ? "error"
        : "debug";
      // XXX TODO include ...State
      console[level]({...data, msg: `frontend.${msg}`});
    }

    function queryString(kv = {}) {
      return (new URLSearchParams(kv)).toString();
    }

    function debounce(delay, f) {
      let timeout;

      return function() {
        const f_ = () => f.apply(this, arguments);

        if (timeout)
          clearTimeout(timeout);

        timeout = setTimeout(f_, delay);
      };
    }

    class Container {
      constructor(id) {
        this.id = id;
      }

      static async create() {
        log("container.creating");

        const createResponse = await POST("containers/create");
        const createResult = await createResponse.json();

        log("container.created", {container: createResult.Id});

        return new Container(createResult.Id);
      }

      async start() {
        if (!this.id)
          throw "Container.start() called on object with no id";

        await POST(`containers/${this.id}/start`);
        log("container.started", {container: this.id});
      }

      async resizeTty(w, h) {
        if (!this.id)
          throw "Container.resizeTty() called on object with no id";

        await POST(`containers/${this.id}/resize?${queryString({w, h})}`);
        log("container.resized-tty", {container: this.id, cols: w, rows: h});
      }

      attachSocket() {
        // XXX TODO: Switch to wss
        const url = new URL(`containers/${this.id}/attach/ws?logs=1&stream=1&stdin=1&stdout=1&stderr=1`, document.location);
        url.protocol = "ws";

        log("socket.opening", {container: this.id, url});
        return new WebSocket(url);
      }
    }

    class UrlState {
      static get(_, key) {
        return this.query.get(key);
      }

      static has(_, key) {
        return this.query.has(key);
      }

      static deleteProperty(_, key) {
        const query = this.query;
        query.delete(key);
        this.query = query;
      }

      static set(_, key, value) {
        const query = this.query;
        query.set(key, value);
        this.query = query;
      }

      static get query() {
        return (new URL(document.location)).searchParams;
      }

      static set query(query) {
        history.replaceState(null, "", `?${query.toString()}`);
      }
    }

    const State = new Proxy(new Map(), UrlState);

    /****/

    launch()
      .catch(error => log("launch.failed", {error}));

    async function launch() {
      log("launch");

      const term = new Terminal({
        fontFamily: "'IBM Plex Mono', monospace",
      });
      term.open(document.getElementById("terminal"));
      term.focus();
      term.onTitleChange(title => {
        log("title-changed", {title});
        document.title = title;
      });

      const fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      fitAddon.fit();

      window.addEventListener("resize", debounce(200, () => fitAddon.fit()));

      term.write("ATM0DT17607067425\r\n");

      /****/

      if (State.container && !State.container.match(/^[a-zA-Z0-9_-]+$/))
        throw "container query parameter contains unpermitted characters";

      let container;

      if (State.container) {
        log("launch.existing", {container: State.container});
        container = new Container(State.container);
      } else {
        log("launch.new");
        container = await Container.create();
        await container.start();
      }

      State.container = container.id;

      term.onResize(debounce(200, ({cols, rows}) => container.resizeTty(cols, rows)));
      container.resizeTty(term.cols, term.rows);

      log("socket.attaching", {container: container.id});
      const socket = container.attachSocket();

      socket.addEventListener("close", close => {
        log("socket.closed", {container: container.id, code: close.code});
        term.write("NO CARRIER\r\n");
        delete State.container;
      });

      const attachAddon = new AttachAddon.AttachAddon(socket);
      term.loadAddon(attachAddon);
    }
  </script>
</body>
</html>

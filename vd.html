<!doctype html>
<html>
<head>
  <title>VisiData Cloud</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="vendor/xterm.css">
  <style>
    body {
      display: flex;
      flex-direction: column;

      margin: 0;
      height: 100vh;
    }
    #terminal {
      flex: auto;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>
  <script src="vendor/xterm.js"></script>
  <script src="vendor/xterm-addon-attach.js"></script>
  <script src="vendor/xterm-addon-fit.js"></script>
  <script>
    async function POST(url, options = {}) {
      const response = await fetch(url, {...options, method: "POST"});

      if (!response.ok) {
        log("request.failed", {response});
        throw `POST ${url} failed`;
      }

      return response;
    }

    function log(msg, data = {}) {
      const level = msg.match(/(^|\b)failed(\b|$)/)
        ? "error"
        : "debug";
      console[level]({msg, ...data});
    }

    function queryString(kv = {}) {
      return (new URLSearchParams(kv)).toString();
    }

    function debounce(delay, f) {
      let timeout;

      return function() {
        const f_ = () => f.apply(this, arguments);

        if (timeout)
          clearTimeout(timeout);

        timeout = setTimeout(f_, delay);
      };
    }

    class Container {
      constructor(id) {
        this.id = id;
      }

      static async create() {
        log("container.creating");

        const createResponse = await POST("containers/create");
        const createResult = await createResponse.json();

        log("container.created", {container: createResult.Id});

        return new Container(createResult.Id);
      }

      async start() {
        if (!this.id)
          throw "Container.start() called on object with no id";

        await POST(`containers/${this.id}/start`);
        log("container.started", {container: this.id});
      }

      async resizeTty(w, h) {
        if (!this.id)
          throw "Container.resizeTty() called on object with no id";

        await POST(`containers/${this.id}/resize?${queryString({w, h})}`);
        log("container.resized-tty", {container: this.id, cols: w, rows: h});
      }

      attachSocket() {
        // XXX TODO: Switch to wss
        // XXX TODO: Switch to our own server endpoint
        // XXX TODO: Ensure the server does Origin checking and eventually authn/authz
        const url = new URL(`containers/${this.id}/attach/ws?logs=1&stream=1&stdin=1&stdout=1&stderr=1`, document.location);
        url.protocol = "ws";

        return new WebSocket(url);
      }
    }

    /****/

    launch()
      .catch(error => log("launch.failed", {error}));

    async function launch() {
      log("launch");

      const term = new Terminal();

      const fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);

      term.open(document.getElementById("terminal"));
      fitAddon.fit();

      window.addEventListener("resize", debounce(200, () => fitAddon.fit()));

      /****/

      const existingContainerId = (new URL(document.location)).searchParams.get("container");

      if (existingContainerId && !existingContainerId.match(/^[a-zA-Z0-9_-]+$/))
        throw "container query parameter contains unpermitted characters";

      let container;

      if (existingContainerId) {
        log("launch.existing", {container: existingContainerId});
        container = new Container(existingContainerId);
      } else {
        log("launch.new");
        container = await Container.create();
        await container.start();
      }

      history.replaceState(null, "", `?${queryString({container: container.id})}`);

      term.onResize(debounce(200, ({cols, rows}) => container.resizeTty(cols, rows)));
      container.resizeTty(term.cols, term.rows);

      log("launch.attaching", {container: container.id});

      const socket = container.attachSocket();

      socket.addEventListener("error", event => {
        log("launch.attach-failed", {container: container.id});
        term.write("Failed to attach to container.");
      });

      const attachAddon = new AttachAddon.AttachAddon(socket);
      term.loadAddon(attachAddon);
    }
  </script>
</body>
</html>
